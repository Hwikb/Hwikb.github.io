<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序算法</title>
      <link href="/2025/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2025/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2025/04/27/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2025/04/27/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>有一个半月没有更新了，可能是因为前段时间琐碎的事情比较多，本文介绍一下前缀和，前缀和是处理数组的一种技巧，用一个数组来存储下标从1到i的和，通常情况下这样可以减少时间复杂度，下面通过列举几道题来感受一下这个方法，下面的题目大多来自于Acwing。</p><h2 id="Acwing3723-字符串查询"><a href="#Acwing3723-字符串查询" class="headerlink" title="Acwing3723 字符串查询"></a>Acwing3723 字符串查询</h2><p>给你单词S和Q个询问，每次询问时，你会得到整数A、B、C和D。我们令单词X是由S的第A到B个字母组成，单词Y是由S的第C到D个字母组成。你需要回答，是否能够重新排列单词Y中的字母，得到单词X。</p><p>输入格式：第一行输入一个单词S，仅由小写字母组成。第二行输入一个正整数Q。接下来的Q行，每行四个整数A，B，C，D。</p><p>输出格式：每次询问，如果能，输出DA，否则输出NE。   1&lt;&#x3D;|S|&lt;&#x3D;50000。</p><h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>简单来说，就是看这两个区间内的(a,z)的字符个数是否相同，一个最朴实无华的方法就是把这两个字字符串截下来，然后对其进行排序，最后再挨个比较，当然，不出意外的话会超时。这种情况下的时间复杂度是O((b-a)*log(b-a))，最差情况就是 O(nlog(n)),比这个复杂度小的只有O(n)(明显这道题是不可能有O(1)的)，所以就需要寻找一种方法，在遍历一遍或几遍S后，便可判断出结果。</p><p>我们可以预处理一个前缀和数组 sum[i][c]，表示前 i 个字符中，字母 c 出现的次数。这样对于任意区间 [l, r]，字母 c 的出现次数就是 sum[r][c] - sum[l-1][c]。只要两个区间内26个字母的出现次数都相等，就说明可以通过重排得到相同的字符串。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">50010</span><span class="token punctuation">,</span>M<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">int</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>string str<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>s<span class="token punctuation">[</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>s<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>s<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>str<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>str<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>s<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> q<span class="token punctuation">;</span>cin<span class="token operator">>></span>q<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token operator">>></span>d<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"DA"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"NE"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先把每个位置上出现的字母标记为 1。然后对每个字母做前缀和，s[j][i]就是前j个字符中第i个字母出现的总次数。最后对两个区间内出现的每个字母个数进行比较。这种方法通过预处理数组得到每一个字符前缀和，处理的时间复杂度是O(n)，可以方便后续的比较。</p><h2 id="Acwing1230-K倍区间"><a href="#Acwing1230-K倍区间" class="headerlink" title="Acwing1230 K倍区间"></a>Acwing1230 K倍区间</h2><p>给定一个长度为N的数列，$A_1,A_2,… A_N$,如果其中一段连续子序列$A_i,A_{i+1},…A_{j}$之和是K的倍数，我们就称区间[i,j]是K倍区间。请求出数列中一共有多少个K倍区间。</p><p>输入格式：第一行包含两个整数N和K。以下N行每行包含一个整数$A_{i}$。<br>输出格式：输出一个整数，代表K倍区间的数目。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>一个最简单的想法就是通过前缀和得到一个新的数组nums，然后用双循环来遍历这个新的数组，判断每个区间是否是K的倍数，这个复杂度是$O(n^2)$,绝对也会超时，这道题明显是希望我们可以找到一个方法，通过遍历一次数组就可以得到结果，我们可以对nums[i]对K取余，假如说nums[i]与nums[j]的余数一致，那说明[i,j]就是K倍区间。当我们遍历到nums[m]余数为a，只需要看前面有几个余数为a的即可。取余运算在这种算法题目中是非常常见的，一般可以多往这方面想想。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">,</span>K<span class="token punctuation">;</span>    cin<span class="token operator">>></span>N<span class="token operator">>></span>K<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">nums</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">sum</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">v</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>sum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>K<span class="token punctuation">;</span>        ans<span class="token operator">+=</span>v<span class="token punctuation">[</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        v<span class="token punctuation">[</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">+</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还需要注意的一小点就是余数为0的，本身就可以作为一个区间，所以最后需要再加上v[0]。</p><h2 id="Acwing-3574乘积数量"><a href="#Acwing-3574乘积数量" class="headerlink" title="Acwing 3574乘积数量"></a>Acwing 3574乘积数量</h2><p>给定一个长度为n且不包含0的整数序列$a_1,a_2,…,a_n$。请你计算以下两值：<br>1.使得$a_{l}×a_{l+1}×…×a_{r}$为负的索引对(l,r)(l&lt;&#x3D;r)的数量。<br>2.使得$a_{l}×a_{l+1}×…×a_{r}$为正的索引对(l,r)(l&lt;&#x3D;r)的数量。</p><p>输入格式：<br>第一行输入一个整数n。<br>第二行包含n个整数$a_1,…,a_n$。</p><p>输出格式：<br>输出单个空格隔开的两个整数，分别表示负的索引对数和正的索引对数。</p><p>数据范围:</p><p>$1 \leq n \leq 2×10^5$</p><p>$-10^9 \leq a_i \leq 10^9$</p><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>在这到题里面，$a_i$只需要考虑是不是正的就行了，为了方便一些，我打算把大于0的全部都换成1，小于0的全部都换成-1，这道题里就不做前缀和了，直接前缀积，反正现在的数全部都是1和-1，相乘之后也只会是1和-1，假如nums[j]&#x3D;-1,那我们可以看前面有几个nums[i]&#x3D;-1，这样[i+1,j]就是正的索引对；相反，前面有几个nums[i]&#x3D;1,这样[i+1,j]就是负的索引对；nums[j]&#x3D;1也是类似的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">2e5</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> plus<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> minus<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> retp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> retm<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>retp<span class="token operator">+=</span>plus<span class="token punctuation">;</span>retm<span class="token operator">+=</span>minus<span class="token punctuation">;</span>plus<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>retp<span class="token operator">+=</span>minus<span class="token punctuation">;</span>retm<span class="token operator">+=</span>plus<span class="token punctuation">;</span>minus<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>retm<span class="token operator">+</span>minus<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>retp<span class="token operator">+</span>plus<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题和前面的那道K倍区间是类似的。</p><h2 id="Acwing3493-最大的和"><a href="#Acwing3493-最大的和" class="headerlink" title="Acwing3493.最大的和"></a>Acwing3493.最大的和</h2><p>给定一个长度为n的正整数数列$a_1,a_2,…,a_n$。初始时，数列中的元素要么处于可选状态，要么处于不可选状态。</p><p>你可以选择一个长度恰好为k的区间[i,i+k-1]，使得$a_i \sim a_{i+k-1}$这k个元素的状态全部变为可选状态。</p><p>请问，在经过次操作之后，所有处于可选状态的元素之和最大是多少。</p><p>输入格式：</p><p>第一行包含两个整数n和k。</p><p>第二行包含n个整数$a_i$.</p><p>第三行包含一个长度为n的01序列，如果第i个数为1，表示$a_i$的初始状态为可选，如果第i个数为0，表示$a_i$的初始状态不可选。</p><p>输出格式：</p><p>一行一个整数，表示答案。</p><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><p>简单而言，这道题目的意思就是有一个数组，目前只有部分元素使可选的，现在可以使一个长度为k的区间内的全部都变为可选，使处于可选状态的元素之和最大，<br>原来的数组可选部分的元素和是固定的，现在一个区间内的数组全部变为可选，也就是说这样会有一个增加量，想要元素之和最大，那么这个增加量需要是最大的。</p><p>此时，我们可以用两次前缀和，第一次就是对a[i]原数组，第二次是对a[i]*b[i],然后遍历一次数组，找到最大的增加量即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1e5</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>k<span class="token punctuation">;</span>ll a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>ll aa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>ll bb<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>n<span class="token operator">>></span>k<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>aa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>aa<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>bb<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ll cha<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>k<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cha<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>cha<span class="token punctuation">,</span><span class="token punctuation">(</span>aa<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>aa<span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>bb<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>bb<span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>cha<span class="token operator">+</span>bb<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Acwing5295"><a href="#Acwing5295" class="headerlink" title="Acwing5295"></a>Acwing5295</h2><p>给定一个长度为n的整数数组$a_0,a_1,…,a_{n-1}$.</p><p>函数sum(l,r)的定义如下：</p><ul><li>如果$l&#x3D;r$,则$sum(l,r)&#x3D;0$。</li><li>如果$l&lt;r$，则$sum(l,r)&#x3D;\sum_{i&#x3D;l}^{r-1}a_{i}$。</li></ul><p>请你找到一个三元组(x,y,z),要求：</p><ol><li>$0 \leq x \leq y \leq z \leq n$</li><li>sum(0,x)-sum(x,y)+sum(y,z)-sum(z,n)的值是尽可能大的。</li></ol><p>输入格式：</p><p>第一行包含整数n。<br>第二行包含n个整数$a_0,a_1,…,a_{n-1}$。</p><p>输出格式:</p><p>在一行内输出三个整数，表示满足条件的整数三元组(x,y,z)。</p><p>数据范围:</p><p>$1 \leq n \leq 5000,-10^9 \leq a_i \leq 10^9$。</p><h4 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先肯定是需要对原来的数组做前缀和的，接下来需要确定三个数，最直接的方法应该是叠加三个for循环，这个时间复杂度是$O(n^3)$，但肯定不会通过全部的测试用例。我们可以先确定中间的y，然后在(1,y)中寻找x使得sum(0,x)-sum(x,y)是最大的，然后在(y,n)中间寻找z，使得sum(y,z)-sum(z,n)是最大的，这样在确定y的条件下，就可以得到需要的最大值。为了得到整体的最大值，我们可以遍历整个数组来确定y，这样的时间复杂度是$O(n^2)$。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span><span class="token operator">&amp;</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> nums<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span><span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">long</span> <span class="token keyword">long</span> maxSum<span class="token operator">=</span><span class="token operator">-</span><span class="token number">0x3f3f3f3f3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>z<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>yy<span class="token operator">&lt;=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>yy<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">long</span> <span class="token keyword">long</span> res1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">0x3f3f3f3f3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> res2<span class="token operator">=</span><span class="token operator">-</span><span class="token number">0x3f3f3f3f3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">int</span> tx<span class="token punctuation">,</span>tz<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> xx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>xx<span class="token operator">&lt;=</span>yy<span class="token punctuation">;</span>xx<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">long</span> <span class="token keyword">long</span> tt<span class="token operator">=</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>xx<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">getSum</span><span class="token punctuation">(</span>xx<span class="token punctuation">,</span>yy<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>tt<span class="token operator">></span>res1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>res1<span class="token operator">=</span>tt<span class="token punctuation">;</span>tx<span class="token operator">=</span>xx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> zz<span class="token operator">=</span>yy<span class="token punctuation">;</span>zz<span class="token operator">&lt;=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>zz<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">long</span> <span class="token keyword">long</span> tt<span class="token operator">=</span><span class="token function">getSum</span><span class="token punctuation">(</span>yy<span class="token punctuation">,</span>zz<span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">getSum</span><span class="token punctuation">(</span>zz<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>tt<span class="token operator">></span>res2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>res2<span class="token operator">=</span>tt<span class="token punctuation">;</span>tz<span class="token operator">=</span>zz<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>res1<span class="token operator">+</span>res2<span class="token operator">></span>maxSum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>maxSum<span class="token operator">=</span>res1<span class="token operator">+</span>res2<span class="token punctuation">;</span>x<span class="token operator">=</span>tx<span class="token punctuation">;</span>y<span class="token operator">=</span>yy<span class="token punctuation">;</span>z<span class="token operator">=</span>tz<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>z<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Acwing3956"><a href="#Acwing3956" class="headerlink" title="Acwing3956"></a>Acwing3956</h2><p>给定一个长度为n的数组$a_1,a_2,…,a_n$。</p><p>现在，要将该数组从中间截断，得到三个非空子数组，要求三个子数组内各元素之和都相等。</p><p>请问，共有多少种不同的截断方法。</p><p>输入格式:</p><p>第一行包含整数n。</p><p>第二行包含n个整数$a_1,a_2,…,a_n$</p><p>输出格式：<br>输出一个整数，表示截断方法的数量。</p><p>数据范围:<br>$1 \leq n \leq 10^5,-10000 \leq a_i \leq 10000$。</p><h4 id="题目分析：-1"><a href="#题目分析：-1" class="headerlink" title="题目分析："></a>题目分析：</h4><p>得到 三个非空子数组的和都相等，说明数组的和需要是3的倍数才行。这道题大概率也是得找出遍历一遍前缀和数组就能得到结果的方法，那么每当我们遍历到nums[j]时，看其是否满足是nums[n]的三分之二，然后再看其前面有多少个nums[i]是nums[n]的三分之一倍，这样就要求在遍历数组的时候将是nums[n]的三分之一的nums[i]的个数存储起来。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span><span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">3</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">||</span> n<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> point<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ans<span class="token operator">+=</span>point<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>point<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一个需要注意的点就是下面这两个if判断语句的顺序不能颠倒，可以试想一种情况(0,0,0,0,0,0,0),一个数组全为0的话，如果将顺序颠倒就会出现一种情况：只分成了两个数组，而第三个是空的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2025/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2025/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>本文中，我将要介绍一下关于二叉树遍历的先关知识，包括bfs和dfs，以及递归等方法。这些知识和题目在初学时可能有些难度，但通过循序渐进的学习，每天的积累也能done it.我在写这篇文章的时候也发现之前忽略的细节，也收获不少。</p><p>遍历二叉树：是按照某条搜索路径巡访树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。常见的遍历方法有先序遍历，中序遍历和后序遍历。这三种遍历方法通过树的结构用递归可以简单实现，非递归方法可以用栈和队列。下面从层序遍历开始讲起。</p><h2 id="Leetcode102二叉树的层序遍历"><a href="#Leetcode102二叉树的层序遍历" class="headerlink" title="Leetcode102二叉树的层序遍历"></a>Leetcode102二叉树的层序遍历</h2><p>有一个二叉树的根结点root，返回其结点值的层序遍历。即逐层地，从左到右访问所有节点。</p><p>eg.输入：root&#x3D;[3,9,20,null,null,15,7]。输出:[[3],[9,20],[15,7]]</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>层序遍历是一种典型的广度优先搜索方法，可以通过队列先进先出的性质来进行层序遍历（当一个节点的左右节点入栈后，将其本身弹出栈），如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/Hwikb/pic_bed@main/img/cenxubianli.gif" alt="image1"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span>ans<span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>ret<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span>now<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> val<span class="token operator">=</span>now<span class="token operator">-></span>val<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在答案中要求的是一层在一个向量中，所以在此加了一个for循环，循环的次数是根据队列中元素的数量确定的，当把本来位于队列中的元素弹出去后也就意味着下一层的都入队了。</p><p>与之类似的leetcode103和leetcode107可以通过相同的方法解决。</p><h2 id="Leetcode104-二叉树的最大深度"><a href="#Leetcode104-二叉树的最大深度" class="headerlink" title="Leetcode104 二叉树的最大深度"></a>Leetcode104 二叉树的最大深度</h2><p>二叉树的最大深度是指从根节点到最远叶子结点的最长路径上的结点数。</p><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>一般来说二叉树相关的题目绝大部分都是可以用递归来解决的，递归可以理解成是树深度优先搜索。递归就是将一个问题分解成更小的子问题，把握两个核心要点：</p><ol><li>核心在于拆分问题，每次调用都是在解决更小的子问题。在二叉树中一般是将父节点相关的问题转化成左右子节点的问题。</li><li>递归必须有终止条件，把终止条件先确定好。在二叉树中一般为某个节点为空，或该节点的左右子结点均为空。</li></ol><p>当然，我比较提倡一题多解，这道题也可以用广度优先搜索解决，和上个题的代码基本一致，只需要在每次for循环后加1即可。</p><p>对这道题目而言，递归的终止条件是该节点时空的；拆分成子问题就是求左子树和右子树的深度，哪个深就取哪个，然后再加上1(父节点也占一个高度)。</p><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><ol><li>深度优先(递归)</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>求链表的长度和这个类似</p><ol start="2"><li>广度优先(队列)</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span>now<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>right<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ans<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p>最小深度是从根节点到最近叶子结点的最短路径上结点的数量。</p><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><p>用递归的话，终止条件就是该节点为空。怎么拆分子问题呢？求左子树和右子树上的最小深度，然后再取较小的一个。那么看一下以下代码是否正确：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>INT_MAX<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个是我一开始的想法，这个是不正确的，我们想一种情况，就是如果一棵树只有右子节点，那么这个代码的结果就是1，因为minDepth(root-&gt;left)&#x3D;0。那么这个不是我们想要得到的结果。一个非空的节点存在三种状态：1.左右子节点均存在。2.左子节点存在右子节点不存在。3.右子节点存在左子节点不存在。如果是情况1的话，上面的return后面的代码是没有问题的。如果是另外两种情况呢，一个节点的深度是0，另一个的是m(一个大于0的数)，我们想取m,所以直接max(minDepth(root-&gt;left),minDepth(root-&gt;right))+1即可，完整代码看下方：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">!=</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span>root<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>INT_MAX<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>广度优先的话还是用队列</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minDepthbfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span>now<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> now<span class="token operator">-></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> ans<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ans<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode101对称二叉树"><a href="#leetcode101对称二叉树" class="headerlink" title="leetcode101对称二叉树"></a>leetcode101对称二叉树</h2><p>给你一个二叉树的根结点root，检查它是否轴对称。</p><p>eg.输入：root&#x3D;[1,2,2,3,4,4,3],输出:true</p><p>输入:root&#x3D;[1,2,2,null,3,null,3],输出：false</p><h4 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h4><p>这棵树是否对称，在于根结点的左子树和右子树是否为镜像关系，所先把研究对象从整棵树变成左右子树。</p><ol><li>深度优先搜索(递归)</li></ol><ul><li>终止条件，若左子树和右子树对应位置均为空，则符合；若左子树和右子树对应位置一个是空，一个不是空，则不符合，对应位置的值是不相等也是不符合。</li><li>拆分成子问题，若当前比较的是结点p和q，那么子问题就是比较p-&gt;left和p-&gt;right 以及 p-&gt;right 和p-&gt;left。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>p<span class="token punctuation">,</span>TreeNode<span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> q<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> q<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>val<span class="token operator">==</span>q<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token function">check</span><span class="token punctuation">(</span>p<span class="token operator">-></span>left<span class="token punctuation">,</span>q<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>p<span class="token operator">-></span>right<span class="token punctuation">,</span>q<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>广度优先(队列)</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span>left<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode<span class="token operator">*</span>right<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span> right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">-></span>val<span class="token operator">!=</span>right<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个方法的相似之处就是比较left-&gt;left与right-&gt;right 以及left-&gt;right和right-&gt;left是否相等，这也是这道题的本质所在。</p><h2 id="leetcode112路径总和1"><a href="#leetcode112路径总和1" class="headerlink" title="leetcode112路径总和1"></a>leetcode112路径总和1</h2><p>有一个二叉树的根节点root和一个表示目标和的整数targetSum。判断该树中是否存在根节点到叶子结点的路径，这条路径上所有节点值相加等于目标和targetSum。如果存在，返回trur;否则，返回false。</p><h4 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h4><p>所有节点的值相加等于目标和，这个就要求我们在遍历节点的时候，需要记录从从节点到该节点的路径和，到叶子结点的时候再判断路径和是否等于目标值。</p><ol><li>深度优先搜索(递归)</li></ol><ul><li>拆分子问题：root的左右结点到叶子结点的路径和是否等于target-root-&gt;val。</li><li>终止条件：叶子结点的值是否等于target减去它所有祖先节点的值(不包括它自己)。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span>root<span class="token operator">-></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token operator">==</span>sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token operator">||</span><span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>广度优先搜索(队列)<br>之前有队列来对二叉树进行层序遍历的时候，是用了一个队列将整个二叉树进行了层序遍历，没有计算路径和。我们可以再建立一个队列，来存储到从根节点到相应结点的路径和，并判断 如果是叶子结点的话是否等于路径和。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasPathSumque</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>q_node<span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>q_value<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>q_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q_node<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>q_node<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span>now_node<span class="token operator">=</span>q_node<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> now_value<span class="token operator">=</span>q_value<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q_node<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> now_node<span class="token operator">-></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> now_value<span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>q_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token operator">-></span>val<span class="token operator">+</span>now_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>q_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>right<span class="token operator">-></span>val<span class="token operator">+</span>now_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode113路径总和2"><a href="#leetcode113路径总和2" class="headerlink" title="leetcode113路径总和2"></a>leetcode113路径总和2</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>eg.输入：root &#x3D;[5,4,8,11,null,13,4,7,2,null,null,5,1],targetSum&#x3D;22。输出：[[5,4,11,2],[5,8,4,5]]</p><h4 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h4><p>此题的困难点在于需要找出完整的路径，如果用深度优先搜索的方法，需要用到回溯。从根节点开始，我们创建一个向量开始存储节点的值，当到第一个根结点的时候(左下侧的根节点)，先看是否是目标路径，然后将最后一个元素弹出向上回溯，再到其他根结点。如果用广度优先搜索，我们可以在将左右子结点入队的时候用哈希表将其父节点存储起来，当找到对应的目标叶子结点的时候，再一步一步的找其父节点。</p><ol><li>深度优先搜索(递归)</li></ol><ul><li>终止条件：该节点是叶子结点，并且路径和满足目标值。</li><li>拆分子问题：该节点的左右子节点和新的target。</li><li>还要注意的是需要从左下角的叶子节点回溯到右下角的叶子节点。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Deepfirst</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span>ret<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>path<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span>path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>target<span class="token operator">-=</span>root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span>target<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>targetSum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较重要的一点是需要从叶子结点回溯到叶子结点。</p><ol start="2"><li>广度优先搜索(队列)</li></ol><p>用广度优先搜索的时候，如果我们想从叶子结点回溯到头结点，那就需要在结点入队的时候用哈希表将结点对应的父节点存储起来，方便回溯。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ret<span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token punctuation">,</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>parent<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getpath</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>temp<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>node<span class="token operator">=</span>parent<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">reverse</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span>q_node<span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q_value<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>q_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q_node<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>q_node<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span>now_node<span class="token operator">=</span>q_node<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> now_value<span class="token operator">=</span>q_value<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q_node<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> now_node<span class="token operator">-></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_value<span class="token operator">==</span>targetSum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">getpath</span><span class="token punctuation">(</span>now_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>parent<span class="token punctuation">[</span>now_node<span class="token operator">-></span>left<span class="token punctuation">]</span><span class="token operator">=</span>now_node<span class="token punctuation">;</span>q_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>left<span class="token operator">-></span>val<span class="token operator">+</span>now_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>parent<span class="token punctuation">[</span>now_node<span class="token operator">-></span>right<span class="token punctuation">]</span><span class="token operator">=</span>now_node<span class="token punctuation">;</span>q_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>q_value<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>now_node<span class="token operator">-></span>right<span class="token operator">-></span>val<span class="token operator">+</span>now_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码可能有一点长，我来捋一下，一开始是层序遍历，用到了一个队列来存储节点，然后是路径总和1，又增加了一个队列用来存储从头结点到该节点的路径和，再就是这道题，在将结点入队的同时又记录该节点的父结点，并加上了回溯的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2025/03/07/%E6%A0%88-stack/"/>
      <url>/2025/03/07/%E6%A0%88-stack/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我将介绍一下栈的基本用法以及单调栈相关的知识</p><h2 id="Leetcode1047-删除字符串中的所有相邻重复项"><a href="#Leetcode1047-删除字符串中的所有相邻重复项" class="headerlink" title="Leetcode1047.删除字符串中的所有相邻重复项"></a>Leetcode1047.删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 s 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>eg.输入：“abbaca”   输出：“ca”</p><p>此题比较明显可以用栈数据结构来解决，对于每个字符依次压入栈，并判断和栈顶的元素是否相等，相等则pop。需要注意的一点是字符串已经内置了栈的操作，vector也是。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>string stk<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token operator">:</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>x<span class="token operator">==</span>stk<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">return</span> stk<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode20-有效的括号"><a href="#leetcode20-有效的括号" class="headerlink" title="leetcode20.有效的括号"></a>leetcode20.有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：左括号必须用相同类型的右括号闭合;左括号必须以正确的顺序闭合;每个右括号都有一个对应的相同类型的左括号。</p><p>这个是一道经典的可以用栈解决的问题，后来的括号是先被匹配的，符合栈的后进先出的特点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>pairs<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token char">')'</span><span class="token punctuation">,</span><span class="token char">'('</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token char">']'</span><span class="token punctuation">,</span><span class="token char">'['</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token char">'&#125;'</span><span class="token punctuation">,</span><span class="token char">'&#123;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span>stk<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token operator">:</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pairs<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>pairs<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借助哈希表，用右括号来判断是应该出栈还是入栈</p><h2 id="leetcode394-字符串解码"><a href="#leetcode394-字符串解码" class="headerlink" title="leetcode394.字符串解码"></a>leetcode394.字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[ encoded_string ]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>eg.输入：s&#x3D;”3[ a ]2[ bc ]”;输出：“aaabcbc”。  输入：s&#x3D;”3[ a2[ c ]]”; 输出：”accaccacc”</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><ol><li>对于一对括号内重复的字符串，我们需要知道这个子串需要重复多少次，并且还要将这个子串从原来的字符串中提取出来。</li><li>依次从第一个字符开始遍历，遇到左括号就将左括号前的数字和左括号前的字符长度压入栈中(用哈希表)，遇到右括号，可以得到有括号前的字符长度，这样就能将子串提取出来，并对这串子串重复操作。</li></ol><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">decodeString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span> stk<span class="token punctuation">;</span>string ans<span class="token punctuation">;</span><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token operator">:</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>count<span class="token operator">=</span>count<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>x<span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token char">'['</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>count<span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ans<span class="token operator">+=</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string substr<span class="token operator">=</span>ans<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">,</span>n<span class="token operator">-</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ans<span class="token operator">+=</span>substr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Leetcode32最长有小括号"><a href="#Leetcode32最长有小括号" class="headerlink" title="Leetcode32最长有小括号"></a>Leetcode32最长有小括号</h2><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>eg. 输入：” （ ））”;输出：2。  输入：”）（）（））” ;输出：4</p><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>子串一定是以”（”开始，以”）”结束的。遇到”（”就push，遇到”）”就pop,并记录一下最大长度。</p><h4 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> maxlen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>stk<span class="token punctuation">;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>maxlen<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>maxlen<span class="token punctuation">,</span>i<span class="token operator">-</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> maxlen<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一开始的时候将-1压入栈中，是为了可以与“）….”类型的字符配对。并且配对后，如果栈为空，继续将”）”的索引压入栈中，方便后续的计算。</p><h2 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h2><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p><p>eg.输入：pushed&#x3D;[1,2,3,4,5],poped&#x3D;[4,5,3,2,1] 输出：true。<br>pushed&#x3D;[1,2,3,4,5],poped&#x3D;[4,3,5,1,2] 输出：false。 1不能在2之前弹出。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> pushed<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> poped<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>stk<span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>poped<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>poped<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>poped<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pushed<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>poped<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode739-每日温度"><a href="#leetcode739-每日温度" class="headerlink" title="leetcode739 每日温度"></a>leetcode739 每日温度</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>eg.输入：temperatures&#x3D;[ 73,74,75,71,69,72,76,73];输出：[ 1,1,4,2,1,1,0,0]</p><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><ul><li>此题用到的思想就是单调栈，从最后一个元素开始遍历，判断其和栈顶元素的大小，如果小于则直接将其压入栈中，否则，将栈顶元素弹出，直到该元素是大于栈顶元素(或者栈为空)。</li><li>栈中的每个元素需要包含数值的大小和序号。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> temperatures<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span>stk<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token operator">=</span>temperatures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">ans</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">&lt;=</span>temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">0</span><span class="token operator">:</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">-</span>i<span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span>temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode496下一个更大元素"><a href="#leetcode496下一个更大元素" class="headerlink" title="leetcode496下一个更大元素"></a>leetcode496下一个更大元素</h2><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p><p>eg.输入：nums1&#x3D;[ 4,1,2],nums2&#x3D;[ 1,3,4,2] 输出：[ -1,3,-1]</p><h4 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先可以用单调栈的方法把nums[ 2]中所有元素对应的下一个更大的元素求出来，那该怎么存储这些结果，方便nums1中的查找呢？答案是哈希表。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>nums1<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>nums2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> hashmap<span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>stk<span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span>nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">ans</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>hashmap<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>hashmap<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果用hashmap[nums2[ i]]表示，然后用hashmao[ nums1[ i]]来找到对应的结果。</p><h2 id="leetcode503下一个更大元素2"><a href="#leetcode503下一个更大元素2" class="headerlink" title="leetcode503下一个更大元素2"></a>leetcode503下一个更大元素2</h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p><p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p><p>eg.输入:nums&#x3D;[ 1,2,1],输出：[ 2,-1 ,2]</p><h4 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h4><p>这个题目主要多了循环这个特点，意味着可以从头再找。所以我打算先把整个数组逆序压入栈中，然后再用单调栈的方法。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">ans</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>stk<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2025/02/28/%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/02/28/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我将介绍几道链表相关的题目，由浅入深，有些题也比较巧妙，可以学到一些好的思想和解题方法。</p><h2 id="Leetcode21-合并两个升序链表"><a href="#Leetcode21-合并两个升序链表" class="headerlink" title="Leetcode21 合并两个升序链表"></a>Leetcode21 合并两个升序链表</h2><p>将两个升序链表合并成一个新的升序链表并返回。</p><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode <span class="token operator">*</span><span class="token function">MergetwoList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head1<span class="token punctuation">,</span>ListNode<span class="token operator">*</span>head2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span>dummy<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span>p<span class="token operator">=</span>dummy<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>head1 <span class="token operator">&amp;&amp;</span> head2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>val<span class="token operator">&lt;</span>head2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>head1<span class="token operator">=</span>head1<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>head2<span class="token operator">=</span>head2<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>next<span class="token operator">=</span>head1<span class="token operator">?</span>head1<span class="token operator">:</span>head2<span class="token punctuation">;</span><span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>若head1和head2均不空，则取较小的，之后直接p-&gt;next&#x3D;head1?head1:head2把剩下的那部分接过来</li></ul><h2 id="Leetcode-147-对链表进行插入排序"><a href="#Leetcode-147-对链表进行插入排序" class="headerlink" title="Leetcode 147 对链表进行插入排序"></a>Leetcode 147 对链表进行插入排序</h2><p>由于链表本身就是连着的，对其进行插入排序需要重点考虑的是一些指针应该怎么变换</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode <span class="token operator">*</span><span class="token function">insertionSortlist</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span>dummyHead<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummyHead<span class="token operator">-></span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span>lastSort<span class="token operator">=</span>head<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span>curr<span class="token operator">=</span>dummyHead<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lastSort<span class="token operator">-></span>val<span class="token operator">&lt;</span>curr<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>lastSort<span class="token operator">=</span>lastSort<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span>pre<span class="token operator">=</span>dummyHead<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token operator">-></span>next<span class="token operator">-></span>val<span class="token operator">&lt;</span>curr<span class="token operator">-></span>val<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                pre<span class="token operator">=</span>pre<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            lastSort<span class="token operator">-></span>next<span class="token operator">=</span>curr<span class="token operator">-></span>next<span class="token punctuation">;</span>            curr<span class="token operator">-></span>next<span class="token operator">=</span>pre<span class="token operator">-></span>next<span class="token punctuation">;</span>            pre<span class="token operator">-></span>next<span class="token operator">=</span>curr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        curr<span class="token operator">=</span>lastSort<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dummyHead<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>此方法中用到了三个指针，一个是curr，就是目前该排序的节点，一个是lastSort，代表着在这个指针之前的已经是已序的了，还有是一个pre,他的作用是为了帮助curr，找到他应该放到哪里。</li><li>不好整的就是找到这个节点该插到哪里后，这些指针的指向应该怎么变化。这里我总结了一个小方法：从前向后看，正确的状态应该是pre-&gt;curr,curr-&gt;pre-&gt;next,lastSort-&gt;next&#x3D;curr-&gt;next。那么写code的时候就从后往前写，先有lastSort-&gt;next&#x3D;curr-&gt;next，再curr-&gt;next&#x3D;pre-&gt;next，最后pre-&gt;next&#x3D;curr，这样就不会有野指针出现了（应该是这样，我也不是百分之百确定，百分之九十九确定）。</li></ul><h2 id="Leetcode23-合并K个升序链表"><a href="#Leetcode23-合并K个升序链表" class="headerlink" title="Leetcode23 合并K个升序链表"></a>Leetcode23 合并K个升序链表</h2><p>在上上节中介绍了一个桶排序，当时是把数值分配到了若干个桶中，将每个桶中的数值排序后再进行合并，其中每个桶中排序好的数据就是一个升序链表，当时合并的方法比较简单粗暴，就是1与2先合并，然后再与3合并，依次类推。</p><p>这里介绍一种分治合并，和归并排序的思想有点像，先两两合并，合并后链表的长度减半，再两两合并，直到最终只有一个链表。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode <span class="token operator">*</span><span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head1<span class="token punctuation">,</span>ListNode<span class="token operator">*</span>head2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span>dummy<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span>p<span class="token operator">=</span>dummy<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>head1 <span class="token operator">&amp;&amp;</span>head2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>val<span class="token operator">&lt;</span>head2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>head1<span class="token operator">=</span>head1<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>head2<span class="token operator">=</span>head2<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>next<span class="token operator">=</span>head1<span class="token operator">?</span>head1<span class="token operator">:</span>head2<span class="token punctuation">;</span> <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode <span class="token operator">*</span><span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span>lists<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span>  <span class="token keyword">return</span> lists<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">></span>r<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token function">merge</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">merge</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode <span class="token operator">*</span><span class="token function">mergeKLists</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span>lists<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Leetcode141-环型链表"><a href="#Leetcode141-环型链表" class="headerlink" title="Leetcode141 环型链表"></a>Leetcode141 环型链表</h2><p>该题有两种比较合适的解法</p><ul><li>快慢指针，一个指针一次走一步，另一个指针一次走两步，如果链表中有环的话，那么一定会在环中的某个结点相遇</li><li>哈希表，从链表的头结点开始遍历，把遍历过的节点均放到哈希表中，如果是循环链表的话，那么哈希表中就一定会出现重复的节点。</li></ul><p>1.快慢指针法:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">CycleList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span>slow<span class="token operator">=</span>head<span class="token punctuation">;</span>ListNode<span class="token operator">*</span>fast<span class="token operator">=</span>head<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fast<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span> fast<span class="token operator">-></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>slow<span class="token operator">=</span>slow<span class="token operator">-></span>next<span class="token punctuation">;</span>fast<span class="token operator">=</span>fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.哈希表法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span>seen<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>seen<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>seen<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>head<span class="token operator">=</span>head<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="leetcode160-相交链表"><a href="#leetcode160-相交链表" class="headerlink" title="leetcode160 相交链表"></a>leetcode160 相交链表</h2><p>给你两个但链表的头结点headA和headB，请你找出并返回两个单链表相交的起始节点，两个链表不存在相交节点，返回null</p><ul><li>很明显，此题如果要是用哈希表的话直接就秒了，先把第一个链表遍历一遍，把所有的节点都装到哈希表，再遍历另一个链表，如果其中的节点在哈希表中是存在的，那么就是相交链表。</li><li>还有一种非常巧妙的双指针的方法，A链表表示成a+c,B链表表示成b+c,一个指针先把A遍历一遍后再去遍历B，另一个先把B遍历一遍后再去遍历A，这样一定会在走了a+b+c步之后相遇(如果两个链表没有相交的部分则可以把两个链表理解成a+nullptr,b+nullptr,他们在走了a+b步之后都是nullptr)。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>headA<span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span>headB<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span>    ListNode<span class="token operator">*</span>pA<span class="token operator">=</span>headA<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span>pB<span class="token operator">=</span>headB<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pA<span class="token operator">!=</span>pB<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        pA<span class="token operator">=</span>pA<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">?</span>headB<span class="token operator">:</span>pA<span class="token operator">-></span>next<span class="token punctuation">;</span>        pB<span class="token operator">=</span>pB<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">?</span>headA<span class="token operator">:</span>pB<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> pA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用一句话来形容这个方法：我走过你走过的路，只为与你相拥。</p><h2 id="Leetcode19-删除链表中的倒数第N个节点"><a href="#Leetcode19-删除链表中的倒数第N个节点" class="headerlink" title="Leetcode19 删除链表中的倒数第N个节点"></a>Leetcode19 删除链表中的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第n个节点，并返回头结点。</p><ul><li>一种比较自然的想法是先看看链表中一共有多少节点（m），删除倒数第n个也就意味着是正数第(m-n+1)个</li><li>另一种方法自然就是双指针了，双指针在链表中的运用比较多。先设置一个dummy，指向head,让两个指针(p1,p2)指向dummy。先让p1走n步，然后两个指针再一起走，p1指向最后一个节点的时候，p2-&gt;next就是要删除的节点了。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode <span class="token operator">*</span>dummy<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dummy<span class="token operator">-></span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>ListNode<span class="token operator">*</span>p1<span class="token operator">=</span>dummy<span class="token punctuation">;</span>ListNode<span class="token operator">*</span>p2<span class="token operator">=</span>dummy<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p1<span class="token operator">=</span>p1<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p1<span class="token operator">=</span>p1<span class="token operator">-></span>next<span class="token punctuation">;</span>p2<span class="token operator">=</span>p2<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p2<span class="token operator">-></span>next<span class="token operator">=</span>p2<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Leetcode876链表的中间节点"><a href="#Leetcode876链表的中间节点" class="headerlink" title="Leetcode876链表的中间节点"></a>Leetcode876链表的中间节点</h2><p>给你一个单链表，请你找出并返回链表的中间节点，如果有两个中间节点，则返回第二个。</p><ul><li>用快慢指针的方法，一个指针一次走一步，另一个指针一次走两步。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode <span class="token operator">*</span><span class="token function">middle</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode <span class="token operator">*</span>p1<span class="token operator">=</span>head<span class="token punctuation">;</span>ListNode <span class="token operator">*</span>p2<span class="token operator">=</span>head<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&amp;&amp;</span>p2<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p1<span class="token operator">=</span>p1<span class="token operator">-></span>next<span class="token punctuation">;</span>p2<span class="token operator">=</span>p2<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">return</span> p1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果对于有两个中间节点的链表，我想返回第一个应该怎么办？仔细观察一下，我们只要更改一下while循环中的条件即可,换成(p-&gt;next &amp;&amp;p-&gt;next-&gt;next)。</p><h2 id="Leetcode143重排链表"><a href="#Leetcode143重排链表" class="headerlink" title="Leetcode143重排链表"></a>Leetcode143重排链表</h2><p>给定一个单链表L的头结点head,单链表L表示为:<br>$$<br>L_1-&gt;L_2-&gt;…-&gt;L_{n-1}-&gt;L_{n}<br>$$<br>请将其重新排列后变为:<br>$$<br>L_0-&gt;L_n-&gt;L_1-&gt;L_{n-1}-&gt;L_2-&gt;L_{n-2}-&gt;…<br>$$<br>不能只是单纯的改变结点内部的值，而是需要世界的进行结点交换。</p><ul><li>把原来的链表改成前面取一个后面取一个，以此类推。先找到链表的中间节点，将链表分成两部分，把后面的那部分链表反转一下，然后再合并两个链表。此题步骤相对较多，可以帮助巩固一些基本的操作。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode <span class="token operator">*</span><span class="token function">middleNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span>slow<span class="token operator">=</span>head<span class="token punctuation">;</span>ListNode<span class="token operator">*</span>fast<span class="token operator">=</span>head<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>slow<span class="token operator">=</span>slow<span class="token operator">-></span>next<span class="token punctuation">;</span>fast<span class="token operator">=</span>fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> slow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span><span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span>prev<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span>curr<span class="token operator">=</span>head<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>prev<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>val<span class="token punctuation">,</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>curr<span class="token operator">=</span>curr<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> prev<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mergeList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>l1<span class="token punctuation">,</span>ListNode<span class="token operator">*</span>l2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span>l1_tmp<span class="token punctuation">;</span>ListNode<span class="token operator">*</span>l2_tmp<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">!=</span><span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> l2<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>l1_tmp<span class="token operator">=</span>l1<span class="token operator">-></span>next<span class="token punctuation">;</span>l2_tmp<span class="token operator">=</span>l2<span class="token operator">-></span>next<span class="token punctuation">;</span>l1<span class="token operator">-></span>next<span class="token operator">=</span>l2<span class="token punctuation">;</span>l1<span class="token operator">=</span>l1_tmp<span class="token punctuation">;</span>l2<span class="token operator">-></span>next<span class="token operator">=</span>l1<span class="token punctuation">;</span>l2<span class="token operator">=</span>l2_tmp<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span>mid<span class="token operator">=</span><span class="token function">middleNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span>l1<span class="token operator">=</span>head<span class="token punctuation">;</span>ListNode<span class="token operator">*</span>l2<span class="token operator">=</span>mid<span class="token operator">-></span>next<span class="token punctuation">;</span>mid<span class="token operator">-></span>next<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>l2<span class="token operator">=</span><span class="token function">reverseList</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mergeList</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Leetcode2-两数相加"><a href="#Leetcode2-两数相加" class="headerlink" title="Leetcode2 两数相加"></a>Leetcode2 两数相加</h2><p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><p>示例：<br>$$<br>2-&gt;4-&gt;3 \<br>5-&gt;6-&gt;4 \<br>7-&gt;0-&gt;8 \<br>$$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode <span class="token operator">*</span>Hwikb<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode <span class="token operator">*</span>current<span class="token operator">=</span>Hwikb<span class="token punctuation">;</span><span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">||</span>l2<span class="token operator">||</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>sum<span class="token operator">+=</span>flag<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>l1<span class="token operator">-></span>val<span class="token punctuation">;</span>l1<span class="token operator">=</span>l1<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>l2<span class="token operator">-></span>val<span class="token punctuation">;</span>l2<span class="token operator">=</span>l2<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>flag<span class="token operator">=</span>sum<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>current<span class="token operator">-></span>next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>current<span class="token operator">=</span>current<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">return</span> Hwikb<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>专门为大于10的节点立了一个flag，相当巧妙。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序题目</title>
      <link href="/2025/02/22/%E6%8E%92%E5%BA%8F%E7%BB%83%E4%B9%A0/"/>
      <url>/2025/02/22/%E6%8E%92%E5%BA%8F%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文介绍几道排序相关的练习题，这几道题也比较有趣。</p><h2 id="错误票据"><a href="#错误票据" class="headerlink" title="错误票据"></a>错误票据</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的 ID号。全年所有票据的 ID 号是连续的，但 ID 的开始数码是随机选定的。因为工作人员疏忽，在录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号。你的任务是通过编程，找出断号的 ID 和重号的 ID 。假设断号不可能发生在最大和最小号。</p><p>输入描述：要求程序首先输入一个整数N(N&lt;100)表示后面的行数，接着读入N行数据。每行数据长度不相等，是用空格分开的若干个(不大于100个)正整数(不大于10e5)。</p><p>输出描述：要求程序输出1行，含两个整数m，n,用空格分隔，其中，m表示断号ID，n表示重号ID。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>这道题如果能直接得到一个数组，那就很容易就可以解决，不管是排序还是什么。这道题的难点在于怎么读入数据。</p><p>介绍一下怎么按行读入，getline()，接收一个字符串，可以接收空格并输出，需要包含”#include&lt; string &gt;”。需要注意的是当同时使用cin&gt;&gt;和getline()时，在cin&gt;&gt;输入流完成之后，getline()之前，需要通过</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">str<span class="token operator">=</span><span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样的方式将回车符作为输入流cin以清除缓存，如果不这样在控制台上就不会出现getline()的输入提示，而是直接跳过，因为程序默认将之前的变量作为输入流。</p><p>现在已经将读入的整行数字以字符串的形式保存，接下来就是需要将其读入数组，stringstream是字符串流。流和存储在内存中的字符串string对象是绑定的，可以在多种数据类型之间实现自动格式化。包含在#include&lt; sstream &gt;中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> value<span class="token operator">=</span><span class="token number">520</span><span class="token punctuation">;</span>stringstream ssin<span class="token punctuation">;</span>ssin<span class="token operator">&lt;&lt;</span>value<span class="token punctuation">;</span><span class="token keyword">int</span> iConvertValue<span class="token punctuation">;</span>ssin<span class="token operator">>></span>iConvertValue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三行是将流的内容转化成字符串，第五行又将流的内容以int的类型输入给iConvertValue。</p><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>value<span class="token punctuation">;</span><span class="token keyword">int</span> maxvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>minvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> m<span class="token punctuation">,</span>q<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>string line<span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>stringstream <span class="token function">ssin</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>ssin<span class="token operator">>></span>value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">></span>maxvalue<span class="token punctuation">)</span> maxvalue<span class="token operator">=</span>value<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">&lt;</span>minvalue<span class="token punctuation">)</span> minvalue<span class="token operator">=</span>value<span class="token punctuation">;</span> a<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>minvalue<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>maxvalue<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  m<span class="token operator">=</span>j<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>  q<span class="token operator">=</span>j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout<span class="token operator">&lt;&lt;</span>m<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为数字的范围是小于1e5的，所以我先建立1e5个桶，然后把这些数据扔到桶里，在(minvalue,maxvalue)这个范围内，哪个桶里没有数据，那它就是缺少的数值，哪个桶里有2个数据，那它就是重复的那一个。</p><h2 id="封闭图形个数"><a href="#封闭图形个数" class="headerlink" title="封闭图形个数"></a>封闭图形个数</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>蓝桥王国，数字的大小不仅仅取决于它们的数值大小，还取决于它们所形成的“封闭图形”的个数。</p><p>数字1,2,3,5,7中没有形成封闭图形，而数字0,4,6,8分别形成了一个封闭图形，数字8则形成了2个封闭图形，并且封闭图形的个数是可以累加的，例如68，一共就有三个封闭图形。</p><p>在比较两个数的大小时，如果他们封闭图形个数不同，那么封闭图形个数较多的更大。如果封闭图形的个数是相等的，那么数值大的更大。</p><p>输入格式：第一行包含一个整数n,表示给定的数字个数；第二行包含n个待排序的数字。<br>输出格式：输出一行，就是对应排序后的结果，每两个数字之间用一个空格分隔。</p><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><ul><li>首先那得确定一下这个数字里面一共有几个洞，可以把数字转化成字符串，然后逐个字符看一下，这里我建立了两个哈希表，一个里面是有一个洞的数字，另一个是有两个洞的数字，都是字符型的，这样方便查找。</li><li>需要比较的是一个数里面洞的个数，如果相等时也需要比较数值的大小，这里可以用向量vector&lt; pair&lt; int,int&gt; &gt;,里面有两个数值，先比第一个，相等的话就比第二个。这样排序完成之后将向量里面第二个值赋给数组即可。</li></ul><h4 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">closefigure</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> str2<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token char">'0'</span><span class="token punctuation">,</span><span class="token char">'4'</span><span class="token punctuation">,</span><span class="token char">'6'</span><span class="token punctuation">,</span><span class="token char">'9'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> str3<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token char">'8'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> close_data<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> hole_data<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>string m<span class="token operator">=</span><span class="token function">to_string</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> hole_data<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>str3<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> hole_data<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>close_data<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>hole_data<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sort</span><span class="token punctuation">(</span>close_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>close_data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>close_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">closefigure</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三国游戏"><a href="#三国游戏" class="headerlink" title="三国游戏"></a>三国游戏</h2><p>小蓝正在玩一款游戏。游戏中魏(X)蜀(Y)吴(Z)三个国家拥有一定量的士兵X，Y，Z（一开始都认为是0）。游戏有n个可能发生的时间，每个时间之间相互独立且最多发生一次，当第i个时间发生时会分别让X，Y，Z增加A_i,B_i,C_i.</p><p>当游戏结束时(有所时间发生与否已经确定)，如果X，Y，Z的其中一个大于另外两个之和，我们认为其获胜。小蓝想知道游戏结束时如果有其中一个国家获胜，最多发生了多少个事件?如果不存在任何能让某国获胜的情况，请输出 −1。</p><p>输入格式：输入的第一行包含一个整数n.<br>第二行包含n个整数表示A_i,相邻整数之间使用一个空格分隔。<br>第三行包含n个整数表示B_i,相邻整数之间使用一个空格分隔。<br>第四行包含n个整数表示C_i,相邻整数之间使用一个空格分隔。</p><p>输出格式：输出一行表示答案。</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>这个题有几个困惑点，就是每个事件是等概率发生的，那到底应该怎么确定应该是哪几个事件发生呢？到底是哪个国家获胜呢，可能本来这个国家兵力雄厚，但发生了一个事件，他的兵力又不雄厚了。</p><p>在此从哪个国家获胜为出发点，因为一共就只有三个国家，分三种情况也就可以了。假如现在我们已经确定让魏国获胜了，那我们应该确定让哪几个事件发生呢。这里就是用到贪心算法了，哪个事件对魏国最有利，就先让哪个事件发生。对魏国有利，就意味着(X[i]-Y[i]-Z[i])是大于零的，所以让t[i]&#x3D;X[i]-Y[i]-Z[i],并且对t[i]累加，累加到它是小于等于0的时候，就可以确定有多少事件发生了。然后再计算另外两个国家获胜时最多的事件个数，三者取最大即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">int</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span> </span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> M<span class="token operator">=</span><span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>t<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">;</span><span class="token keyword">signed</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>x<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span>y<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>t<span class="token operator">+</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>t<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">signed</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">>></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">>></span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> res<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>res<span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/2025/02/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2025/02/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>​&nbsp;&nbsp;在本文中，我将介绍10种经典的排序方法，一个很简单的排序，却有很多方法可以解决，每种方法也各有优缺点，每种方法也体现了一种思想，我认为算法中最重要的就是学会一些思想，这样才能做到以不变应万变。本文中的代码均是使用的C&#x2F;C++(文章中的动图参考 <a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a> 。若是侵权，我立刻删除)</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>从列表第一个元素开始，比较相邻两个元素值的大小，让小的到前面。</li><li>当遍历完一轮后，最大的元素就已经到最后一个了，所以共需遍历n-1次。</li></ul><h4 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h4><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>temp<span class="token operator">=</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span>b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">bubblesort</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码理解起来很容易，n个数需要进行n-1轮遍历，每轮遍历需要进行n-1次，然后就是比较大小，让小的到前面即可。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>选择排序，顾名思义，就是选出来一个进行排序。该算法分为已排序部分和未排序部分。</li><li>具体而言，对于未排序的部分，遍历出来最小值，让其到最前面，归到已排序的部分。</li><li>遍历n-1轮后完成整个数组的排序。</li></ul><h4 id="动图展示-1"><a href="#动图展示-1" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://raw.githubusercontent.com/Hwikb/pic_bed/main/img/selectionSort.gif" alt="image1"></p><h4 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectsort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cin<span class="token operator">>></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">selectsort</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该代码理解起来也比较容易，就不过多叙述了。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>顾名思义，就是对于一个数，把他放到一个合适的位置。整个数组分为已排序部分和未排序部分。</li><li>初始时，第一个数相当于是有序的，故从第二个数开始插，将其插入到合适的位置。</li><li>重复上述步骤，直至整个数组均为有序。</li></ul><h4 id="动图展示-2"><a href="#动图展示-2" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://cdn.jsdelivr.net/gh/Hwikb/pic_bed@main/img/insertionSort.gif" alt="image1"></p><h4 id="代码部分-2"><a href="#代码部分-2" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> key<span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一个for循环中的i表示的对第i个数进行插入操作，往下的j&#x3D;i-1，是i前面的数。</li><li>循环体条件((j&gt;&#x3D;0)&amp;&amp;(key &lt; arr[j]))，j是下标，其最小是0，如果key要是比arr[j]小,那么arr[j]就往后移(给key让位置,因为它得往前面插)，key再接着比较前面的数。</li><li>当第j个数不满足循环体条件时，则key就找到位置了，就到第j个数的后面。</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>Shell Sort是插入排序的一种改进的版本，其先将数组分成若干字数组，对每个子数组进行插入排序，逐步缩小子数组的间隔，最终完成整个数组的排序。</p><ul><li>先选择一个增量序列，将列表分成若干子列表。</li><li>对每个子列表进行插入排序。</li><li>逐步缩小增量，重复上述分组和排序过程，直到增量为1。</li></ul><h4 id="代码部分-3"><a href="#代码部分-3" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">shellsort</span><span class="token punctuation">(</span>T array <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> h<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token operator">&lt;</span>n<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>h<span class="token operator">=</span>h<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">>=</span>h<span class="token operator">&amp;&amp;</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>array<span class="token punctuation">[</span>j<span class="token operator">-</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">-=</span>h<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token operator">:</span><span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>j<span class="token operator">-</span>h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>h<span class="token operator">/=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想是将一个大问题分解成若干小问题，然后分别解决这些小问题，然后将结果合并起来，最终得到整个问题的解。</p><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li><strong>分解</strong>：将待排序的数组分成两个子数组，每个子数组包含大约一半的元素。</li><li><strong>解决</strong>，递归的对每个子数组进行排序。</li><li><strong>合并</strong>，将以排序的子数组合并成一个有序的数组。</li></ul><h4 id="动图展示-3"><a href="#动图展示-3" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://cdn.jsdelivr.net/gh/Hwikb/pic_bed@main/img/mergeSort.gif" alt="image1"></p><h4 id="代码部分-4"><a href="#代码部分-4" class="headerlink" title="代码部分"></a>代码部分</h4><p>1.迭代的方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    T<span class="token operator">*</span> a<span class="token operator">=</span>arr<span class="token punctuation">;</span>    T<span class="token operator">*</span> b<span class="token operator">=</span><span class="token keyword">new</span> T<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> seg<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>seg<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>seg<span class="token operator">+=</span>seg<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>start<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>start<span class="token operator">+=</span>seg<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> low<span class="token operator">=</span>start<span class="token punctuation">;</span>            <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>start<span class="token operator">+</span>seg<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> high<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>start<span class="token operator">+</span>seg<span class="token operator">+</span>seg<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k<span class="token operator">=</span>low<span class="token punctuation">;</span>            <span class="token keyword">int</span> start1<span class="token operator">=</span>low<span class="token punctuation">,</span>end1<span class="token operator">=</span>mid<span class="token punctuation">;</span>            <span class="token keyword">int</span> start2<span class="token operator">=</span>mid<span class="token punctuation">,</span>end2<span class="token operator">=</span>high<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>start1<span class="token operator">&lt;</span>end1<span class="token operator">&amp;&amp;</span>start2<span class="token operator">&lt;</span>end2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>start2<span class="token punctuation">]</span><span class="token operator">?</span>a<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">:</span>a<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token comment">//如果想要倒序排序的话  while(start1&lt;end1&amp;&amp;start2&lt;end2)&#123;b[k++]=a[start1]>a[start2]?a[start1++]:a[start2++];&#125;即可</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>start1<span class="token operator">&lt;</span>end1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>start2<span class="token operator">&lt;</span>end2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        T<span class="token operator">*</span>temp<span class="token operator">=</span>a<span class="token punctuation">;</span>        a<span class="token operator">=</span>b<span class="token punctuation">;</span>        b<span class="token operator">=</span>temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">!=</span>arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        b<span class="token operator">=</span>a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>先建立了a和b两个指针，一个指向传入数组的首地址，一个指向新建数组的首地址。</li><li>seg可以理解为已序子数组的长度，一开始每个元素可以看成是一个已序的子数组，所以seg开始设为1，每次合并时已序部分的长度会×2。</li><li>start1和start2指向相邻两个已序字数组的第一个元素，下面三个while循环就是将这两个已序子数组合并成一个已序子数组</li><li>25行的判断语句存在的意义：因为a和b会进行交换，如果交换了奇数次，a会指向新建的数组，b会指向arr，而a是排序好的数组，所以在此把a中的值赋给b,并让b指向a,最后再delete b，这样不会影响到arr。</li></ul><p>2.递归的方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge_sort_recursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> reg<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token operator">>=</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> len<span class="token operator">=</span>end<span class="token operator">-</span>start<span class="token punctuation">,</span>mid<span class="token operator">=</span>start<span class="token operator">+</span><span class="token punctuation">(</span>len<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> start1<span class="token operator">=</span>start<span class="token punctuation">,</span>end1<span class="token operator">=</span>mid<span class="token punctuation">;</span><span class="token keyword">int</span> start2<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end2<span class="token operator">=</span>end<span class="token punctuation">;</span><span class="token function">merge_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>reg<span class="token punctuation">,</span>start1<span class="token punctuation">,</span>end1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">merge_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>reg<span class="token punctuation">,</span>start2<span class="token punctuation">,</span>end2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> k<span class="token operator">=</span>start<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>start1<span class="token operator">&lt;=</span>end1 <span class="token operator">&amp;&amp;</span> start2<span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>reg<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>start2<span class="token punctuation">]</span><span class="token operator">?</span>arr<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">:</span>arr<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>start1<span class="token operator">&lt;=</span>end1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>reg<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>start2<span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>reg<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>start<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>reg<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">merge_sort_recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> reg<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">merge_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>reg<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>先把整个数组进行分割，划分成两部分，然后对左边这部分进行排序后再对右边这部分进行排序，最后将这两部分进行合并</li><li>终止条件就是start和end的大小关系，最小的子数组的长度是2，再划分后就会终止，然后对这个子数组排序</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>Quick Sort是一种高效的排序散发，基于分治法的核心思想。他的核心思想是选择一个基准元素(pivot),将列表分为两部分，一部分小于基准元素，一部分大于基准元素，然后递归地对这两部分进行排序，快速排序的时间复杂度是O(n log n),在实际应用中有优异的性能。</p><h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>从列表中随机选择一个元素作为基准（可以随机选择），一下代码中选择的是第一个元素。</li><li>将列表重新排序，小于基准元素的放到基准的左侧，大于基准元素的放到基准元素的右侧。</li><li>对基准元素的左侧和右侧的字数组分别进行快速排序</li><li>递归结束后也就对整个数组进行了排序。</li></ul><h4 id="动图展示-4"><a href="#动图展示-4" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://cdn.jsdelivr.net/gh/Hwikb/pic_bed@main/img/quickSort.gif" alt="image1"></p><h4 id="代码部分-5"><a href="#代码部分-5" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> pivot<span class="token operator">=</span>A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>pivot<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>right<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>left<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 快速排序函数</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Partition（）这个函数是用于返回选中元素的下标，是一个标准分割数组的函数</li><li>然后递归的对左侧和右侧进行排序</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>Heapsort是利用堆这种数据结构所设计的一种排序方法。堆积是一种近似完全二叉树，并满足堆积的性质：即子节点的值总是小于（或者大于）它的父节点。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>先创建一个堆[0…..n-1];</li><li>把堆首（最大值）和堆尾互换，让堆首成为已序部分；</li><li>把堆的尺寸缩小1，然后把新的数组顶端的数据调整至相应的部分</li><li>重复步骤2，直到堆的尺寸为1</li></ul><h4 id="动图展示-5"><a href="#动图展示-5" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://cdn.jsdelivr.net/gh/Hwikb/pic_bed@main/img/heapSort.gif" alt="image1"></p><h4 id="代码部分-6"><a href="#代码部分-6" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">max_heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> dad<span class="token operator">=</span>start<span class="token punctuation">;</span><span class="token keyword">int</span> son<span class="token operator">=</span>dad<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>son<span class="token operator">&lt;=</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>son<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span>end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>son<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>son<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>dad<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>dad<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dad<span class="token operator">=</span>son<span class="token punctuation">;</span>son<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>dad<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span>   <span class="token comment">//堆排序</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">max_heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max_heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>max_heapify()函数的作用是把从start到end的这些数据形成一个大顶推</li><li>i&#x3D;len&#x2F;2-1,代表的是最后一个非叶子结点，第一个for循环的目的就是形成一个堆</li><li>第二个for循环的目的是把二叉树的最后一个元素和第一个元素交换位置，并去掉归到已序部分，然后max_heapify(arr,0,i-1)是将顶部的元素移动到合适的位置</li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序通过逐位比较元素的每一位（从最低位到最高位）来实现排序，相当于第一次排序将个位数排好，第二次排序将十位数排好，以此类推。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>找到列表中最大数字的位数，确定需要排序的轮数</li><li>从最低位开始，依次对每一位进行排序</li><li>每一轮排序后，更新列表的排序，直到所有位数排序完成</li></ul><h4 id="动图展示-6"><a href="#动图展示-6" class="headerlink" title="动图展示"></a>动图展示</h4><p><img src="https://cdn.jsdelivr.net/gh/Hwikb/pic_bed@main/img/radixSort.gif" alt="image1"></p><h4 id="代码部分-7"><a href="#代码部分-7" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">maxbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> maxdata<span class="token operator">=</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>maxdata<span class="token operator">&lt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>maxdata<span class="token operator">=</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>maxdata<span class="token operator">>=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>maxdata<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>d<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> d<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">radixsort</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> d<span class="token operator">=</span><span class="token function">maxbit</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>count<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span><span class="token keyword">int</span> radix<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>d<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>k<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span>radix<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>count<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>k<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span>radix<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>temp<span class="token punctuation">[</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>radix<span class="token operator">*=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>temp<span class="token punctuation">;</span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>maxbit()先return 数组中最大值的位数，temp[]是每轮排序结束后把数据暂时放到这个数组中，count[10]如动图中，底部的10个桶</li><li>每轮排序前先将桶中的元素清零，然后再根据这一轮中的某一位数将数据放到桶中，接下来的两个for循环是关键，这样确定了排序前的d[j]在排序后应该在temp中的哪个位置，这个设计很巧妙</li><li>最后再把排序后temp[]中的数值赋给data[]用于下一轮中的排序</li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是一种分布式算法，它将待排序的元素分配到若干个桶中，然后对每个桶中的元素进行排序，最后将所有桶中的元素按顺序合并</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>根据数据的范围和分布，创建若干个桶</li><li>遍历待排序的列表，将每个元素分配到对应的同中</li><li>对每个桶中的元素进行排序</li><li>将所有桶中的元素按顺序合并，得到最终的排序结果</li></ul><h4 id="代码部分-8"><a href="#代码部分-8" class="headerlink" title="代码部分"></a>代码部分</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> BUCKET_NUM <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">explicit</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">mData</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mNext</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> mNext<span class="token punctuation">;</span>    <span class="token keyword">int</span> mData<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span> <span class="token function">insert</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode dummyNode<span class="token punctuation">;</span>    dummyNode<span class="token punctuation">.</span>mNext <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token operator">&amp;</span>dummyNode<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>mData <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> curr<span class="token operator">-></span>mNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    newNode<span class="token operator">-></span>mNext <span class="token operator">=</span> curr<span class="token punctuation">;</span>    pre<span class="token operator">-></span>mNext <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span> <span class="token function">Merge</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode dummyNode<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token operator">&amp;</span>dummyNode<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> head2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>mData <span class="token operator">&lt;</span> head2<span class="token operator">-></span>mData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tail<span class="token operator">-></span>mNext <span class="token operator">=</span> head1<span class="token punctuation">;</span>            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>mNext<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            tail<span class="token operator">-></span>mNext <span class="token operator">=</span> head2<span class="token punctuation">;</span>            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>mNext<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tail <span class="token operator">=</span> tail<span class="token operator">-></span>mNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> tail<span class="token operator">-></span>mNext <span class="token operator">=</span> head1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> tail<span class="token operator">-></span>mNext <span class="token operator">=</span> head2<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">BucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> <span class="token function">buckets</span><span class="token punctuation">(</span>BUCKET_NUM<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxData <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> BUCKET_NUM<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>maxData <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> head <span class="token operator">=</span> buckets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BUCKET_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> <span class="token function">Merge</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> curr<span class="token operator">-></span>mData<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> curr<span class="token operator">-></span>mNext<span class="token punctuation">;</span>        <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>int index&#x3D;(arr[i]*BUCKET_NUM)&#x2F;(maxData+1)来确定arr[i]应该分配到那个桶当中（根据桶的个数和最大值来确定）</li><li>通过链表的插入来对每个桶内的元素排序</li><li>通过合并链表来有序的合并桶内的元素</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog introduce</title>
      <link href="/2025/02/07/blog-introduce/"/>
      <url>/2025/02/07/blog-introduce/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的个人博客！这里是我记录和分享学习心得的地方，主要涵盖算法题解析、论文精读、大模型技术等方向。如果你对这些领域感兴趣，希望能在这里找到一些有价值的内容，也欢迎一起探讨交流。</p><p>在学习过程中，我经常会遇到各种有趣的知识点和技术细节，因此希望通过这个博客将自己的思考整理出来，不仅加深自己的理解，也希望能对其他有类似兴趣的朋友有所帮助。当然，由于个人水平有限，文章中可能会有不够严谨或理解不准确的地方，欢迎大家指出和讨论。</p><p>无论你是刚入门的新手，还是已经有一定经验的同行，都欢迎在评论区留言交流你的想法和见解。我相信，知识的碰撞能带来更多的启发，让我们一起进步！</p><p>感谢你的访问，希望这个博客能成为一个自由讨论和共同成长的学习平台！😊</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
